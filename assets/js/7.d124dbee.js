(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{177:function(e,t,i){"use strict";i.r(t);var a=i(0),_=Object(a.a)({},function(){var e=this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,t=e.$createElement,i=e._self._c||t;return i("div",{staticClass:"content"},[i("h1",{attrs:{id:"什么是-diff-算法"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#什么是-diff-算法","aria-hidden":"true"}},[e._v("#")]),e._v(" 什么是 Diff 算法")]),e._v(" "),i("p",[e._v("虚拟 DOM 需要进行比对才能更新，比对采用的算法就是 Diff 算法，Diff 意为 Different。")]),e._v(" "),i("h2",{attrs:{id:"虚拟-dom-什么时候会被比对？"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#虚拟-dom-什么时候会被比对？","aria-hidden":"true"}},[e._v("#")]),e._v(" 虚拟 DOM 什么时候会被比对？")]),e._v(" "),i("p",[e._v("当数据发生变化的时候，虚拟 DOM 才会做新的比对，什么时候算是数据改变了呢？")]),e._v(" "),i("ul",[i("li",[e._v("当我们调用"),i("code",[e._v("setState")]),e._v("方法的时候，会发生比对。")]),e._v(" "),i("li",[e._v("这个方法是异步的。这样设计的初衷是为了提升底层的性能，因为异步方法不会同步执行，而是会放入异步队列，如果我们 setState 三次，在异步队列中可以合并成一次，这样可以提升性能。")])]),e._v(" "),i("h2",{attrs:{id:"diff-算法"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#diff-算法","aria-hidden":"true"}},[e._v("#")]),e._v(" Diff 算法")]),e._v(" "),i("p",[e._v("首先明确概念，虚拟 DOM 是树形数据结构")]),e._v(" "),i("ul",[i("li",[e._v("两棵虚拟 DOM 树进行比对")]),e._v(" "),i("li",[e._v("从两棵树的根节点进行比对，进行先序遍历")]),e._v(" "),i("li",[e._v("如果发现存在不一样的地方，就停止遍历比对，直接生成一个新的虚拟 DOM 树替换原始的虚拟 DOM 树\n"),i("blockquote",[i("p",[e._v("我们会发现一个问题，如果同层比对，发现不一样就不再往下比对，其他相同的虚拟 DOM 节点就不会复用了，会不会造成浪费？")])])]),e._v(" "),i("li",[e._v("的确是这样，虽然这样做可能会造成 DOM 渲染的一些性能损耗，但也大大的简化了算法上的性能损耗。")]),e._v(" "),i("li",[e._v("React 的虚拟 DOM 其实是同层比对的")])]),e._v(" "),i("h2",{attrs:{id:"比对细节的优化"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#比对细节的优化","aria-hidden":"true"}},[e._v("#")]),e._v(" 比对细节的优化")]),e._v(" "),i("ul",[i("li",[e._v("同层比对的时候，虚拟 DOM 节点是被赋予了 key 值。")]),e._v(" "),i("li",[e._v("数据发生变化，生成新的虚拟节点，被赋予了同样的 key 值，这样就建立起了联系。")]),e._v(" "),i("li",[e._v("那么比对的时候，同 key 值比对，发现异同就更加容易了。这也大大提升了比对的性能。")]),e._v(" "),i("li",[e._v("一致的内容可以复用，不一致的，缺失的，或者新增的就可以创建新的虚拟 DOM 树。")])]),e._v(" "),i("p",[e._v("因此，我们在 TodoList 的 demo 中是不建议给 item 的 key 值赋 index 的。用 index 作为 key 值，因为 index 是循环遍历出来的项的下标（是按顺序生成，和 item 项没有实际的关联），所以会导致新老虚拟 DOM 节点的 key 值对应不上。这无疑增加了 Diff 算法所耗的性能，因此，使用一个稳定的和 DOM 节点明确绑定的 key 值才是正确的做法。因此我们可以在 demo 中用 item 做 item 的 key 值。")])])}],!1,null,null,null);t.default=_.exports}}]);