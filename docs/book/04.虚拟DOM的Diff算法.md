# 什么是 Diff 算法

虚拟 DOM 需要进行比对才能更新，比对采用的算法就是 Diff 算法，Diff 意为 Different。

## 虚拟 DOM 什么时候会被比对？

当数据发生变化的时候，虚拟 DOM 才会做新的比对，什么时候算是数据改变了呢？

- 当我们调用`setState`方法的时候，会发生比对。
- 这个方法是异步的。这样设计的初衷是为了提升底层的性能，因为异步方法不会同步执行，而是会放入异步队列，如果我们 setState 三次，在异步队列中可以合并成一次，这样可以提升性能。

## Diff 算法

首先明确概念，虚拟 DOM 是树形数据结构

- 两棵虚拟 DOM 树进行比对
- 从两棵树的根节点进行比对，进行先序遍历
- 如果发现存在不一样的地方，就停止遍历比对，直接生成一个新的虚拟 DOM 树替换原始的虚拟 DOM 树
  > 我们会发现一个问题，如果同层比对，发现不一样就不再往下比对，其他相同的虚拟 DOM 节点就不会复用了，会不会造成浪费？
- 的确是这样，虽然这样做可能会造成 DOM 渲染的一些性能损耗，但也大大的简化了算法上的性能损耗。
- React 的虚拟 DOM 其实是同层比对的

## 比对细节的优化

- 同层比对的时候，虚拟 DOM 节点是被赋予了 key 值。
- 数据发生变化，生成新的虚拟节点，被赋予了同样的 key 值，这样就建立起了联系。
- 那么比对的时候，同 key 值比对，发现异同就更加容易了。这也大大提升了比对的性能。
- 一致的内容可以复用，不一致的，缺失的，或者新增的就可以创建新的虚拟 DOM 树。

因此，我们在 TodoList 的 demo 中是不建议给 item 的 key 值赋 index 的。用 index 作为 key 值，因为 index 是循环遍历出来的项的下标（是按顺序生成，和 item 项没有实际的关联），所以会导致新老虚拟 DOM 节点的 key 值对应不上。这无疑增加了 Diff 算法所耗的性能，因此，使用一个稳定的和 DOM 节点明确绑定的 key 值才是正确的做法。因此我们可以在 demo 中用 item 做 item 的 key 值。
